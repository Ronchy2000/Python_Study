"""
深度优先搜索算法除了基于递归实现之外，还可以基于堆栈来实现。同时，为了防止多次遍历同一节点，在使用栈存放节点访问记录时，
我们将「当前节点」以及「下一个将要访问的邻接节点下标」一同存入栈中，
从而在出栈时，可以通过下标直接找到下一个邻接节点，而不用遍历所有邻接节点。

以下是基于堆栈实现的深度优先搜索的算法步骤：
1.定义 graph 为存储无向图的嵌套数组变量，visited 为标记访问节点的集合变量。start 为当前遍
历边的开始节点。定义 stack 用于存放节点访问记录的栈结构。
2. 选择起始节点 w，检查当前节点 u是否为目标节点（看具体题目要求）。
3.如果当前节点么是目标节点，则直接返回结果。
4.如果当前节点u 不是目标节点，则将节点么以及节点u 下一个将要访问的邻接节点下标0放入栈
中，并标记为已访问，即 stack.append（［u,0］），visited.add（u）。
5. 如果栈不为空，取出 stack栈顶元素节点u，以及节点么下一个将要访问的邻接节点下标i。
6. 根据节点1和下标i，取出将要遍历的未访问过的邻接节点。
7. 将节点么以及节点u的下一个邻接节点下标i+1放入栈中。
8. 访问节点2，并对节点进行相关操作（看具体题目要求）。
9.将节点2以及节点2下一个邻接节点下标0放入栈中，并标记为已访问，即 stack.append（［v，
0］）， visited.add（v）。
10. 重复步骤5～9，直到 stack栈为空或找到目标节点为止。
"""
class Solution:
    def dfs_stack(self, graph, u):
        print(u)                            # 访问节点 u
        visited, stack = set(), []          # 使用 visited 标记访问过的节点, 使用栈 stack 存放临时节点
        
        stack.append([u, 0])                # 将节点 u，节点 u 的下一个邻接节点下标放入栈中，下次将遍历 graph[u][0]
        visited.add(u)                      # 将起始节点 u 标记为已访问
        
    
        while stack:
            u, i = stack.pop()              # 取出节点 u，以及节点 u 下一个将要访问的邻接节点下标 i
            
            if i < len(graph[u]):
                v = graph[u][i]             # 取出邻接节点 v
                stack.append([u, i + 1])    # 下一次将遍历 graph[u][i + 1]
                if v not in visited:        # 节点 v 未访问过
                    print(v)                # 访问节点 v
                    stack.append([v, 0])    # 下一次将遍历 graph[v][0]
                    visited.add(v)          # 将节点 v 标记为已访问                
        

graph = {
    "A": ["B", "C"],
    "B": ["A", "C", "D"],
    "C": ["A", "B", "D", "E"],
    "D": ["B", "C", "E", "F"],
    "E": ["C", "D"],
    "F": ["D", "G"],
    "G": []
}

# 基于堆栈实现的深度优先搜索
Solution().dfs_stack(graph, "A")
